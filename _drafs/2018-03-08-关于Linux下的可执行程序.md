---
layout: post
title: "关于Linux下的可执行程序"
date: 2018-03-08 
description: "关于Linux下的可执行程序的加载，启动，动态链接，内存映射"
tag: ELF c 
---   


# 可执行程序
## 一般
一个完成一定任务的程序有两种情况
* 直接在硬件上执行（单片机程序，操作系统）
* 通过操作系统调用执行

一个通过操作系统调用的程序有以下几种情况
* 二进制机器码的程序
* 二进制中间语言性程序（java或c#的class文件）
* 字符型的解释性程序（python，ruby，perl，html，css，javascript，php）

## Linux下的可执行程序
中间 语言的程序和解释性的程序最终的形态也是要通过二进制的程序作为调用的入口，所以本文对二进制程序的一些概念做一些梳理。

首先，影响二进制程序是否可以执行条件有硬件条件（cpu），和软件条件（操作系统），对于软件条件来讲，比如说有linux下的**ELF(Extensible Linking Format)**
格式文件和Windows下的**PE(Portable Executable)格式文件**

对于后台开发，由于Linux使用较为普遍，本文着重对linux的ELF文件的一些加载，重定位，启动过程做一个梳理

## 解剖ELF程序
我们先从一个简单的程序开始看看一个c语言程序从写完代码到执行的时候到底做了什么

#### main.c
```c
int main(int argc, char** argvs) {
    return 0;
}
```
### 编译
```shell
gcc -g main.c -o a.out
```
这里-g的作用是给生成的二进制文件添加上调试信息
填上调试信息之后的好处便是可以找到当前二进制码所对应的c代码，通过下面的方式便可
```shell
 objdump -S a.out |grep "main(" -A20
```

```assembly
int main(int argc, char ** argvs) {
  400474:	55                   	push   %rbp
  400475:	48 89 e5             	mov    %rsp,%rbp
  400478:	89 7d fc             	mov    %edi,-0x4(%rbp)
  40047b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return 0;
  40047f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  400484:	c9                   	leaveq 
  400485:	c3                   	retq   
  400486:	90                   	nop
  400487:	90                   	nop
  400488:	90                   	nop
  400489:	90                   	nop
  40048a:	90                   	nop
  40048b:	90                   	nop
  40048c:	90                   	nop

```
### 一个可执行程序是如何生成的
一个高级语言要转变成可执行的程序，需要通过编译。如果对象操作系统或硬件上无法提供编译环境的需要通过**交叉编译（cross compile）**

c语言的程序到执行为止，需要经过以下阶段[2](http://www.bogotobogo.com/cplusplus/assembly.php)

![compile](https://raw.githubusercontent.com/KuangyiZhu/kuangyizhu.github.io/master/images/2018-03-08/2018-03-08-01.png)
### 工具 
查一句话补充一下在本文中需要使用的工具
#### gcc
编译器
* -g : 添加debug参数
* 去掉g ： 等于strip --debug
#### strip
去除symbol，结果会使文件变小，也增加了对抗逆向工程的能力
#### nm
打印符号表，strip过后，nm的结果为空
#### objdump
* -S : 打印反汇编结果
#### readelf
* -h : 读取文件头信息，EntryPoint为程序入口
* -l : 读取文件段信息
* -all: 打印所有信息
#### xxd
把二进制文件字符化
#### hexdump
把二进制文件字符化
#### ldd
* 列举出依赖的文件
依赖文件的查询顺序可以由以下命令确认
```shell
man ld
The linker uses the following search paths to locate required shared libraries:
1.  Any directories specified by -rpath-link options.
2.  Any directories specified by -rpath options.  The difference between -rpath and -rpath-link is that directories specified by -rpath options are included in the executable and used at runtime, whereas the -rpath-link option is only effective at link time. Searching -rpath in this way is only supported by native linkers and cross linkers which have been configured with the --with-sysroot option.
3.  On an ELF system, for native linkers, if the -rpath and -rpath-link options were not used, search the contents of the environment variable "LD_RUN_PATH".
4.  On SunOS, if the -rpath option was not used, search any directories specified using -L options.
5.  For a native linker, the search the contents of the environment variable "LD_LIBRARY_PATH".
6.  For a native ELF linker, the directories in "DT_RUNPATH" or "DT_RPATH" of a shared library are searched for shared libraries needed by it. The "DT_RPATH" entries are ignored if "DT_RUNPATH" entries exist.
7.  The default directories, normally /lib and /usr/lib.
8.  For a native linker on an ELF system, if the file /etc/ld.so.conf exists, the list of directories found in that file. If the required shared library is not found, the linker will issue a warning and continue with the link.
```
### 汇编基础
本文的汇编可以从以下资源来学习[5](https://www.recurse.com/blog/7-understanding-c-by-learning-assembly)
* 汇编的格式 指令 SRC DST
* $代表内存地址
* %代表寄存器

# 程序是如何执行的
## 程序的入口
程序并不是从main函数开始执行的，gcc -o main main.c时，默认会连接libc.so(可以指定-nodefaultlib, -nostdlib取消连接)，并且会添加一个启动代码_start函数(可以指定-nodefaultlib, -nostdlib不添加启动代码)，用于初始化，并提供main函数的argc, argv等参数，_start函数中会调用main函数。[8](http://blog.csdn.net/ayu_ag/article/details/50737209) 

```shell
readelf -h a.out ｜ grep Entry可以看到：
  Entry point address:               0x4003d0
```
程序的入口地址是0x4003d0，也就是_start函数的地址，程序装载到内存后，从0x4003d0(_start)开始执行。

那么，我不想执行_start函数呢，可以通过ld的参数-e指定入口函数，使用gcc -o main mian.c -Wl,-ehello编译，-Wl用于指定后面的参数是给ld的，-e指定入口函数是hello。
## 可执行文件的分段
https://greek0.net/elf.html
https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html
http://blog.csdn.net/anonymalias/article/details/51784803
64位操作系统程序分配(加载)的虚拟起始地址为0x400000，32位系统程序分配(加载)的虚拟起始地址为0x8048000
elf format
上面类型为PHDR的segment，用来包含程序头表本身。




What it basically means is that the program executable is loaded into memory before it can start doing things. The entry point of the executable can be acquired by readelf. But here's another question, why is the entry point given by readelf, not at 0x400000. It turns out that, that entry point is consider the actual point where the OS should start executing, whereas the position between 0x400000 and entry point is used for the EHDR and PHDR, meaning ELF headers and Program Headers. We'll look into this in detail later.

As you can see, we have 3 sections of memory, each of them 4 KiB, and allocated from /home/vagrant/c_tests/memory_layout.

What are these sections?

The first segment: "Text Segment".

The second segment: "Data Segment".

The third segment: "BSS Segment".

Text segment stores the binary image of the process. The data segment stores static variables initialised by the programmer, for example static char * foo = "bar";. The BSS segment stores uninitialised static variables, which are filled with zeros, for example static char * username;.

So it turns out that one can say that 0x400000 for a non-PIE 64 bit ELF executable compiled by gcc on Linux is the exact the same starting point as the 0x0 for the actual executable file itself.

Unlike gcore or manually dereferencing arbitrary pointers, we can see that objdump cannot or will not show us memory contents from 400000 - 400238. Instead it starts showing from 400238. This is because the stuff from 400000 - 400238 are not assembly instructions, they are just metadata, so objdump doesn't bother with them as it's designed to dump assembly code. 
https://stackoverflow.com/questions/14314021/why-linux-gnu-linker-chose-address-0x400000
The start address is usually set by a linker script.

For example, on GNU/Linux, looking at /usr/lib/ldscripts/elf_x86_64.x we see:

...
PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); \
    . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;

http://blog.csdn.net/qq_16209077/article/details/51975605
Linux系统给每个进程分配了4GB的空间，其中 0xC0000000到0xFFFFFFFF 这个地址段是留给系统使用的，主要用于系统（linux 内核)和进程通信和交换数据，   用户可以使用3GB的空间从(0x00000000-0xBFFFFFFF).

http://blog.csdn.net/anonymalias/article/details/51784803
下面是进程地址空间的简易结构图：每个可执行文件生成的时候，虚拟地址空间都会从0x400000开始分配(64位)，32位为0x8048000。 

## 内核是如何执行可执行文件的
https://www.jianshu.com/p/eb39eac9d82e
该入口是由ld链接器默认的链接脚本指定的，当然用户也可以通过参数进行设定。_start由汇编代码实现。大致用如下伪代码表示：
void _start()
{
　　%ebp = 0;
　　int argc = pop from stack
　　char ** argv = top of stack;
　　__libc_start_main(main, argc, argv, __libc_csu_init, __linc_csu_fini,
　　edx, top of stack);
}


https://www.linuxidc.com/Linux/2011-08/41869p2.htm
可以从glibc的源代码目录中sysdeps/generic/libc-start.c看到，__libc_start_main的原型为：

extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),  
        int argc,  
        char *__unbounded *__unbounded ubp_av,  
        void (*init) (void),  
        void (*fini) (void),  
        void (*rtld_fini) (void),  
        void *__unbounded stack_end)  
__attribute__ ((noreturn));  


这些值应该是由内核设置的。

当我们在shell里面调用一个可执行文件，linux会进行以下操作：

（1）shell调用系统调用“execve”，带上参数信息argc/argv。

（2）内核系统调用的handler获得控制，并处理系统调用。在内核代码中，execve对应的handler是"sys_execve"。在x86中，用户模式的应用会使用以下寄存器向内核传递一些必要的参数：

ebx： 指向程序名的指针
ecx：参数数组指针
edx：环境变量数组指针
（3）linux然后调用通用的execve内核系统调用handler，do_execve。该调用建立一个数据结构，并将用户空间的数据拷贝到内核空间，然后调用search_binary_handler。Linux能够同时支持多种可执行文件的格式，比如a.out和ELF。为了实现这种功能，linux利用一个“struct linux_binfmt”数据结构，存储各种二进制格式的加载器的函数指针。search_binary_handler查询并调用合适的加载器（本例子中是load_elf_binary）。加载器首先建立一个数据结构用来存储ELF文件映像。然后，再建立一个内核数据结构，存���相关信息，包括代码大小，数据段起始地址，栈起始地址，等等。然后，为该程序分配用户模式的页表，并将参数以及环境变量拷贝到页面地址中。最后，create_elf_tables()函数将参数指针，环境变量数组指针压入用户模式的栈；start_thread()函数启动_start开始的进程代码。
      当_start标号所在的汇编指令开始执行时，函数的栈帧如下所示：

Stack Top           -------------  
                            argc  
                        -------------  
                            argv pointer  
                        -------------  
                            env pointer  
                        -------------   
然后，这些信息传递给_start函数：
pop %esi                  //获得argc

move %esp, %ecx    //获得argv

当这些信息传递给_start函数以后，_start函数通过将esp的低4位清0（即16字节对齐）来设置我们的主程序的栈的起始地址。

//注：这些代码所在的文件是crtbegin.o, crtend.o, gcrt1.o。



6. 总结

（1）内核加载可执行文件，并建立text/data/bss/stack。此外，内核为参数和环境变量分配页，并将它们压入用户模式栈。
（2）GCC通过crtbegin.o/crtend.o/gcrt1.o来建立程序。另外的默认库默认是动态链接的。可执行文件的开始地址是_start的地址。

（3）控制传递给_start以后，_start从由内核设置的栈中获取参数和环境变量信息，然后调用__libc_start_main。

（4）__libc_start_main初始化必要的数据结构，尤其是C库（比如malloc）和线程环境，然后调用用户的main函数。值得注意的是，__libc_start_main认为main

函数的签名是:

int main(int argc,  char ** argv, char ** env)。

（5）main函数的返回值由__libc_start_main接收，并传递给exit。

## 静态变量
http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/
r8,r9

http://blog.csdn.net/langchibi_zhou/article/details/5744922

https://www.mtyun.com/library/linker
第三列表示变量的名字，这里我们看到局部的静态变量名字被编译器修改为 s_a.1597，我们应该能猜得到编译器这么做的原因。s_a 是一个局部静态变量，作用域限制在定义它的代码块中，所以我们可以在不同的作用域中声明相同名字的局部静态变量，比如我们可以在sum函数中声明另外一个 s_a。但是我们上面提过，局部静态变量属于全局变量的范畴，它是存在于程序运行的整个生命周期的，所以为了支持这个功能，编译器对这种局部的静态变量名字加了一个后缀以便标识不同的局部静态变量。

main对应的指令就是我们自己的main函数了，__libc_csu_init接着会调用_init的指令，然后会调用__do_global_ctors_aux这个 C++ 程序员都应该熟悉的 symbol 对应的指令，__do_global_ctors_aux对应的指令会进行所有的全局变量初始化，或者 C++ 中的全局对象构造等操作。


## 函数的调用
https://stackoverflow.com/questions/42653095/what-is-the-difference-between-retq-and-ret
http://blog.csdn.net/wwh578867817/article/details/40554103
https://www.cs.princeton.edu/courses/archive/spr11/cos217/lectures/15AssemblyFunctions.pdf
https://softwareengineering.stackexchange.com/questions/195385/understanding-stack-frame-of-function-call-in-c-c

function A:
push space for the return value
push parameters
push the return address
jump to the function B
function B:
push the address of the previous stack frame
push values of registers that this function uses (so they can be restored)
push space for local variables
do the necessary computation
restore the registers
restore the previous stack frame
store the function result
jump to the return address
function A:
pop the parameters
pop the return value





# 动态链接
## GOOD
* unit test
* single thread
* soft link
* rpm

http://gotowqj.iteye.com/blog/1926771
rpath
http://blog.csdn.net/absurd/article/details/928972
共享库的初始化和~初始化函数分析





http://blog.csdn.net/gatieme/article/details/51628257
http://blog.csdn.net/A1342772/article/details/77688148
https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/
http://www.cnblogs.com/catch/p/3857964.html


gcc在编译时，除非显示的使用static标签，否则所有程序的链接都是动态链接的，也就是说需要解释器。由此可见，我们的程序在被内核加载到内存，内核跳到用户空间后并不是执行目标程序的，而是先把控制权交到用户空间的解释器，由解释器加载运行用户程序所需要的动态库（比如libc等等），然后控制权才会转移到用户程序。

动态链接器执行在ELF文件中标记为.init的节的代码，进行程序运行的初始化。 
动态链接器把控制传递给程序，从ELF文件头部中定义的程序进入点(main)开始执行。在a.out格式和ELF格式中，程序进入点的值是显式存在的，而在COFF格式中则是由规范隐含定义。

## rebase relocation
https://www.codeproject.com/Articles/9426/Need-for-Rebasing-a-DLL
The loader has to iterate through the relocation section and modify a lot of the module's code. This produces a major performance hit and can really hurt an application's initialization time.
As the loader writes to the module's code pages, the system's copy-on-write mechanism forces these pages to be backed by the system's paging file.

## FPIC

# 如何调试运行中的可执行文件
## pstack
## gcore, gdb
## segment fault原理

https://zh.wikipedia.org/wiki/%E6%A0%B8%E5%BF%83%E8%BD%AC%E5%82%A8
核心文件（core file），也称核心转储（core dump），是操作系统在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写出的一个磁盘文件。这种信息往往用于调试。


https://www.linuxquestions.org/questions/blog/rtmistler-575248/debugging-c-programs-using-gdb-including-core-dumps-36826/
ulimit -c unlimited
Running the ulimit -a command, you will see a report on all user file limits. Core file size is one of these. Typically you'll see a value of zero, this means that core files will not occur.

http://www.cnblogs.com/xiehongfeng100/p/4854344.html
In computing, a segmentation fault (often shortened to segfault) or access violation is a fault raised by hardware with memory protection, notifying an operating system (OS) about a memory access violation; on x86 computers this is a form of general protection fault. In short, a segmentation fault occurs when a program attempts to access a memory location that it is not allowed to access, or attempts to access a memory location in a way that is not allowed (e.g., attempts to write to a read-only location, or to overwrite part of the operating system).

http://man.linuxde.net/objdump
objdump -S -C(demangle)
ptype
群理论和纠错检错

https://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries/
。然后内核会注意到一个称为 .interp 的 ELF 部分，它指明了将要被使用的动态链接器（/lib/ld-linux.so），如清单 1 所示。这与 UNIX® 中的脚本文件的解释器定义（#!/bin/sh）很相似：只是用在了不同的上下文中。

inux 提供了很多种查看和解析 ELF 对象（包括共享库）的工具。其中最有用的一个当属 ldd 命令，您可以使用它来发送共享库依赖项。例如，在 dl 应用程序上使用 ldd 命令会显示如下内容：

readelf 命令是一个有很多特性的实用程序，它让您能够解析和读取 ELF 对象。readelf 有一个有趣的用途，就是用来识别对象内可再定位的项。
readelf -r

https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4
Running the above gives us a simple segmentation fault. Thus proving that /proc/$PID/maps is giving us the truth, there really is nothing between 0-400000

### 参考文献
* [1] : http://blog.csdn.net/demonshir/article/details/8779404  csdn:从elf中读取函数地址 
* [2] : http://www.bogotobogo.com/cplusplus/assembly.php  C++ TUTORIAL - TASTE OF ASSEMBLY - 2018
* [3] : http://blog.csdn.net/emdfans/article/details/26227347 gcc编译 strip使用
* [4] : http://blog.csdn.net/stpeace/article/details/47090255  linux中的strip命令简介------给文件脱衣服
* [5] : https://www.recurse.com/blog/7-understanding-c-by-learning-assembly Understanding C by learning assembly
* [6] : http://blog.csdn.net/unix21/article/details/8466440 readelf和ldd分析elf文件
* [7] : http://man.linuxde.net/ld ld命令
* [8] : http://blog.csdn.net/ayu_ag/article/details/50737209 ELF entry point和装载地址
* [9] : https://stackoverflow.com/questions/14314021/why-linux-gnu-linker-chose-address-0x400000 Why Linux/gnu linker chose address 0x400000?


