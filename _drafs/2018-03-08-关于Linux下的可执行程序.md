---
layout: post
title: "关于Linux下的可执行程序"
date: 2018-03-08 
description: "关于Linux下的可执行程序的加载，启动，动态链接，内存映射"
tag: ELF c 
---   


# 可执行程序
## 一般
一个完成一定任务的程序有两种情况
* 直接在硬件上执行（单片机程序，操作系统）
* 通过操作系统调用执行

一个通过操作系统调用的程序有以下几种情况
* 二进制机器码的程序
* 二进制中间语言性程序（java或c#的class文件）
* 字符型的解释性程序（python，ruby，perl，html，css，javascript，php）

## Linux下的可执行程序
中间 语言的程序和解释性的程序最终的形态也是要通过二进制的程序作为调用的入口，所以本文对二进制程序的一些概念做一些梳理。

首先，影响二进制程序是否可以执行条件有硬件条件（cpu），和软件条件（操作系统），对于软件条件来讲，比如说有linux下的**ELF(Extensible Linking Format)**
格式文件和Windows下的**PE(Portable Executable)格式文件**

对于后台开发，由于Linux使用较为普遍，本文着重对linux的ELF文件的一些加载，重定位，启动过程做一个梳理

## 解剖ELF程序
我们先从一个简单的程序开始看看ELF在执行的时候到底做了什么

#### main.c
```c
int main(int argc, char** argvs) {
    return 0;
}
```
### 编译
```shell
gcc -g main.c -o a.out
```
这里-g的作用是给生成的二进制文件添加上调试信息
填上调试信息之后的好处便是可以找到当前二进制码所对应的c代码，通过下面的方式便可
```shell
 objdump -S a.out |grep "main(" -A20
```

```assembly
int main(int argc, char ** argvs) {
  400474:	55                   	push   %rbp
  400475:	48 89 e5             	mov    %rsp,%rbp
  400478:	89 7d fc             	mov    %edi,-0x4(%rbp)
  40047b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return 0;
  40047f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  400484:	c9                   	leaveq 
  400485:	c3                   	retq   
  400486:	90                   	nop
  400487:	90                   	nop
  400488:	90                   	nop
  400489:	90                   	nop
  40048a:	90                   	nop
  40048b:	90                   	nop
  40048c:	90                   	nop

```

### 解剖ELF 
gcc
strip
objdump
readelf
ldd
ld
nm
### 程序是如何生成的
cross compiling

# 汇编基础

# 程序是如何执行的
## 入口
## 函数
## 可执行文件的分段
## 内核是如何执行可执行文件的


# 动态链接
## rebase relocation
## FPIC

# 如何调试运行中的可执行文件
## pstack
## gcore, gdb

### 参考文献
