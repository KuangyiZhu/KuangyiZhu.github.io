---
layout: post
title: "关于Linux下的可执行程序"
date: 2018-03-08 
description: "关于Linux下的可执行程序的加载，启动，动态链接，内存映射"
tag: ELF c 
---   


# 可执行程序
## 一般
一个完成一定任务的程序有两种情况
* 直接在硬件上执行（单片机程序，操作系统）
* 通过操作系统调用执行

一个通过操作系统调用的程序有以下几种情况
* 二进制机器码的程序
* 二进制中间语言性程序（java或c#的class文件）
* 字符型的解释性程序（python，ruby，perl，html，css，javascript，php）

## Linux下的可执行程序
中间 语言的程序和解释性的程序最终的形态也是要通过二进制的程序作为调用的入口，所以本文对二进制程序的一些概念做一些梳理。

首先，影响二进制程序是否可以执行条件有硬件条件（cpu），和软件条件（操作系统），对于软件条件来讲，比如说有linux下的**ELF(Extensible Linking Format)**
格式文件和Windows下的**PE(Portable Executable)格式文件**

对于后台开发，由于Linux使用较为普遍，本文着重对linux的ELF文件的一些加载，重定位，启动过程做一个梳理

## 解剖ELF程序
我们先从一个简单的程序开始看看一个c语言程序从写完代码到执行的时候到底做了什么

#### main.c
```c
int main(int argc, char** argvs) {
    return 0;
}
```
### 编译
```shell
gcc -g main.c -o a.out
```
这里-g的作用是给生成的二进制文件添加上调试信息
填上调试信息之后的好处便是可以找到当前二进制码所对应的c代码，通过下面的方式便可
```shell
 objdump -S a.out |grep "main(" -A20
```

```assembly
int main(int argc, char ** argvs) {
  400474:	55                   	push   %rbp
  400475:	48 89 e5             	mov    %rsp,%rbp
  400478:	89 7d fc             	mov    %edi,-0x4(%rbp)
  40047b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return 0;
  40047f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  400484:	c9                   	leaveq 
  400485:	c3                   	retq   
  400486:	90                   	nop
  400487:	90                   	nop
  400488:	90                   	nop
  400489:	90                   	nop
  40048a:	90                   	nop
  40048b:	90                   	nop
  40048c:	90                   	nop

```
### 一个可执行程序是如何生成的
一个高级语言要转变成可执行的程序，需要通过编译。如果对象操作系统或硬件上无法提供编译环境的需要通过**交叉编译（cross compile）**

c语言的程序到执行为止，需要经过以下阶段[2](http://www.bogotobogo.com/cplusplus/assembly.php)

![compile](https://raw.githubusercontent.com/KuangyiZhu/kuangyizhu.github.io/master/images/2018-03-08/2018-03-08-01.png)
### 工具 
查一句话补充一下在本文中需要使用的工具
#### gcc
编译器
* -g : 添加debug参数
* 去掉g ： 等于strip --debug
#### strip
去除symbol，结果会使文件变小，也增加了对抗逆向工程的能力
#### nm
打印符号表，strip过后，nm的结果为空
#### objdump
* -S : 打印反汇编结果
#### readelf
* -h : 读取文件头信息，EntryPoint为程序入口
* -l : 读取文件段信息
* -all: 打印所有信息
#### xxd
把二进制文件字符化
#### hexdump
把二进制文件字符化
#### ldd
* 列举出依赖的文件
依赖文件的查询顺序可以由以下命令确认
```shell
man ld
The linker uses the following search paths to locate required shared libraries:
1.  Any directories specified by -rpath-link options.
2.  Any directories specified by -rpath options.  The difference between -rpath and -rpath-link is that directories specified by -rpath options are included in the executable and used at runtime, whereas the -rpath-link option is only effective at link time. Searching -rpath in this way is only supported by native linkers and cross linkers which have been configured with the --with-sysroot option.
3.  On an ELF system, for native linkers, if the -rpath and -rpath-link options were not used, search the contents of the environment variable "LD_RUN_PATH".
4.  On SunOS, if the -rpath option was not used, search any directories specified using -L options.
5.  For a native linker, the search the contents of the environment variable "LD_LIBRARY_PATH".
6.  For a native ELF linker, the directories in "DT_RUNPATH" or "DT_RPATH" of a shared library are searched for shared libraries needed by it. The "DT_RPATH" entries are ignored if "DT_RUNPATH" entries exist.
7.  The default directories, normally /lib and /usr/lib.
8.  For a native linker on an ELF system, if the file /etc/ld.so.conf exists, the list of directories found in that file. If the required shared library is not found, the linker will issue a warning and continue with the link.
```
### 汇编基础
本文的汇编可以从以下资源来学习[5](https://www.recurse.com/blog/7-understanding-c-by-learning-assembly)
* 汇编的格式 指令 SRC DST
* $代表内存地址
* %代表寄存器

# 程序是如何执行的
## 入口
## 函数
## 可执行文件的分段
## 内核是如何执行可执行文件的


# 动态链接
## rebase relocation
## FPIC

# 如何调试运行中的可执行文件
## pstack
## gcore, gdb

### 参考文献
* [1] : http://blog.csdn.net/demonshir/article/details/8779404  csdn:从elf中读取函数地址 
* [2] : http://www.bogotobogo.com/cplusplus/assembly.php  C++ TUTORIAL - TASTE OF ASSEMBLY - 2018
* [3] : http://blog.csdn.net/emdfans/article/details/26227347 gcc编译 strip使用
* [4] : http://blog.csdn.net/stpeace/article/details/47090255  linux中的strip命令简介------给文件脱衣服
* [5] : https://www.recurse.com/blog/7-understanding-c-by-learning-assembly Understanding C by learning assembly
 
